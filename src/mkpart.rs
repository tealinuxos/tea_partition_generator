// this is very simple library, the goal is partitioning sdb

// use crate::installer::blueprint::Partition;
use crate::blueprint::Storage;
use duct::cmd;
use tea_arch_chroot_lib::resource::MethodKind;

// #[derive(Serialize, Deserialize, Debug)]
// pub struct DiskInfo {
//     pub number: u32,
//     #[serde(rename(deserialize = "diskPath"))]
//     pub disk_path: String,
//     pub path: String,
//     pub mountpoint: Option<String>,
//     pub filesystem: String,
//     pub format: bool,
//     pub start: u64,
//     pub end: u64,
//     pub size: u64,
//     pub autogenerated: bool,
// }

pub struct Partgen;

impl Partgen {


    pub fn set_blkdev_partition_table(blk: String, partition_table: String) -> () {
        println!("set {} partition table as {}", blk, partition_table);
        if partition_table == "mbr" {
            // khusus ini conventionnya pakai mbr wkwk, malas ngereplace yang lain lain soalnya
            let _ = cmd!("parted", blk, "--script", "mklabel", "msdos").run();
        } else {
            let _ = cmd!("parted", blk, "--script", "mklabel", partition_table).run();
        }
    }

    pub fn mkpart(blktarget: String, start: u64, end: u64, fs: String, _name: String) {
        let startf = format!("{}s", start);
        let endf = format!("{}s", end);

        println!(
            "Executing parted command: parted {} --script unit s mkpart primary {} {} {}", 
            blktarget, fs, startf, endf
        );

        let _ = cmd!("parted", blktarget, "--script", "unit", "s", "mkpart", "primary", fs, startf, endf).run();
    }

    pub fn mkfs(partition_target: String, fs: String) {
        if fs == "fat32" {
            println!("formatting {} as fat32", partition_target);
            let _ = cmd!("mkfs.vfat", "-F", "32", partition_target).run();
        } else if fs == "btrfs" {
            println!("formatting {} as btrfs", partition_target);
            let _ = cmd!("mkfs.btrfs", "-f", partition_target).run();
        } else if fs == "ext4" {
            println!("formatting {} as ext4", partition_target);
            let _ = cmd!("mkfs.ext4", "-F", partition_target).run();
        }else if fs == "linux-swap" {
            println!("running: mkswap {}", partition_target);
            let _ = cmd!("mkswap", partition_target).run();
        }
    }

    pub fn setflags(blktarget: String, partition_num: u64) -> () {
        let _ = cmd!(
            "parted",
            blktarget,
            "--script",
            "set",
            partition_num.to_string(),
            "boot",
            "on"
        )
        .run();
    }

    pub fn do_dangerous_task_on(storage: Storage, mode: MethodKind) -> i32 {
        if mode == MethodKind::SINGLE {
            if let Some(disk_path_val) = storage.disk_path {
                Self::set_blkdev_partition_table(disk_path_val.clone(), storage.partition_table.unwrap());
            
                if let Some(ref partitions_val) = storage.partitions {
                    for partition_i in partitions_val {
                        Self::mkpart(
                            disk_path_val.clone(),
                            partition_i.start,
                            partition_i.end,
                            partition_i.filesystem.clone().unwrap(),
                            partition_i.path.clone().unwrap(),
                        );
                        Self::mkfs(
                            partition_i.path.clone().unwrap(),  // warning, this is predicted!, 
                                                                                  // /dev/sdxn, n number is generated by kernel
                            partition_i.filesystem.clone().unwrap()
                        );
    
              
                        if let Some(partition_path_val) = partition_i.mountpoint.clone() {
                            if partition_path_val == "/boot/efi" {
                                if let Some(disk_path_val) = partition_i.disk_path.clone() {
                                    Self::setflags(disk_path_val, partition_i.number.clone());
                                }
                            }
                        } else {
                            println!("partition.mountpoint unwrap fail");
                        }
                        
                    }
                } 
            } else {
                println!("SET PARTITION TABLE FAILED");
                return -1;
            }
    
            
    
                // // do partitioning
                // let mut start_blk_idx = 1;
                // for partition in storage {
                //     // runn
                //     let blk_name = format!("{}{}", blk, start_blk_idx);
                    
    
                //     if start_blk_idx == 1 {
                //         // set flags
                //         Self::setflags(blk.clone(), start_blk_idx);
                //     }
    
                //     start_blk_idx = start_blk_idx + 1;
                // }
            -1
        } else if mode == MethodKind::DUAL {
            println!("DUALBOOT mode invoked");
            if let Some(disk_path_val) = storage.disk_path {
                if let Some(ref partitions_val) = storage.partitions {
                    for partition_i in partitions_val {
                        Self::mkpart(
                            disk_path_val.clone(),
                            partition_i.start,
                            partition_i.end,
                            partition_i.filesystem.clone().unwrap(),
                            partition_i.path.clone().unwrap(),
                        );
                        Self::mkfs(
                            partition_i.path.clone().unwrap(),  // warning, this is predicted!, 
                                                                                // /dev/sdxn, n number is generated by kernel
                            partition_i.filesystem.clone().unwrap()
                        );

            
                        if let Some(partition_path_val) = partition_i.mountpoint.clone() {
                            if partition_path_val == "/boot/efi" {
                                if let Some(disk_path_val) = partition_i.disk_path.clone() {
                                    Self::setflags(disk_path_val, partition_i.number.clone());
                                }
                            }
                        } else {
                            println!("partition.mountpoint unwrap fail");
                        }
                        
                    }
                } 
            }
            -1
        } else {
            println!("method unknown");
            -1
        }
        
    }
}